<!doctype html>
<html lang="de-DE">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0b0f14" />
  <title>Zeit – Work & Mobi</title>

  <link rel="stylesheet" href="styles.css" />
  <link rel="manifest" href="manifest.webmanifest" />
</head>

<body data-theme="medium">
  <header class="top">
    <div class="top__left">
      <div class="brand">ZEIT</div>
      <div class="bigclock mono" id="bigClock">--:--:--</div>
      <div class="subline" id="todayLine">—</div>
    </div>

    <div class="top__right">
      <div class="row wrap">
        <div class="seg">
          <button class="seg__btn is-active" id="tabNormal">Normal</button>
          <button class="seg__btn" id="tabMobi">Mobi</button>
        </div>

        <label class="field field--inline">
          <span>Theme</span>
          <select id="themeSel">
            <option value="dark">Dark</option>
            <option value="medium" selected>Medium</option>
            <option value="light">Light</option>
          </select>
        </label>

        <button class="btn btn--ghost" id="btnInstall" style="display:none">Als App installieren</button>
      </div>
    </div>
  </header>

  <main class="container">

    <!-- HERO: big work timer + main controls -->
    <section class="card hero">
      <div class="hero__grid">
        <div>
          <div class="hero__label">Arbeitszeit heute</div>
          <div class="hero__big mono" id="heroWork">00:00:00</div>
          <div class="hero__sub mono" id="heroSub">Pause 00:00:00 · Unterbr. 00:00:00</div>

          <div class="row wrap hero__actions">
            <button class="btn btn--good btn--xl" id="workStart">Start</button>
            <button class="btn btn--warn btn--xl" id="workPause">Pause</button>
            <button class="btn btn--danger btn--xl" id="workStop">Stop</button>
          </div>

          <div class="hint">
            Pause startet <b>nur</b>, wenn du Pause drückst. Wenn Arbeit pausiert ist und keine Pause läuft, wird <b>Unterbrechung</b> getrackt.
          </div>
        </div>

        <div class="hero__right">
          <div class="pill">
            <div class="pill__label">Status Arbeit</div>
            <div class="pill__value mono" id="workStatus">stopped</div>
          </div>
          <div class="pill">
            <div class="pill__label">Status Pause</div>
            <div class="pill__value mono" id="breakStatus">stopped</div>
          </div>

          <div class="pill">
            <div class="pill__label">Geplantes Ende (live)</div>
            <div class="pill__value mono" id="endTime">—</div>
            <div class="pill__sub mono" id="endSub">—</div>
          </div>

          <button class="btn btn--primary" id="btnFinishDay">Arbeitsende</button>
          <div class="mono small" id="finishResult">—</div>
        </div>
      </div>
    </section>

    <!-- NORMAL TAB -->
    <section id="viewNormal">

      <section class="card">
        <div class="card__title">Setup</div>

        <div class="grid">
          <label class="field">
            <span>Startzeit</span>
            <input type="time" id="dayStart" step="60" lang="de-DE" />
            <small class="small">
              Falls am Laptop AM/PM erscheint: einmal AM oder PM auswählen (sonst bleibt es “--”).
            </small>
          </label>

          <label class="field">
            <span>Soll-Arbeitszeit</span>
            <input type="time" id="targetWork" value="07:00" step="60" />
            <small class="small">Nur Arbeitszeit (ohne Pause).</small>
          </label>

          <label class="field">
            <span>Pflichtpause</span>
            <input type="time" id="requiredBreak" value="00:45" step="60" />
          </label>

          <div class="field">
            <span>Quick</span>
            <button class="btn btn--primary btn--shine" id="btnStartNow">Start = jetzt & sofort starten</button>
            <div class="row wrap" style="margin-top:10px">
              <label class="check">
                <input type="checkbox" id="noGlide" />
                <span>Keine Gleitzeit</span>
              </label>

              <label class="check">
                <input type="checkbox" id="autoResume" checked />
                <span>Nach Pflichtpause automatisch zurück zu Arbeit</span>
              </label>

              <label class="check">
                <input type="checkbox" id="notifyOnBreak" />
                <span>Notification bei Pflichtpause</span>
              </label>

              <button class="btn btn--ghost" id="btnEnableNotify">Notifications erlauben</button>
            </div>
          </div>
        </div>
      </section>

      <section class="card" id="glideCard">
        <div class="card__title">Gleitzeit</div>

        <div class="grid grid--4">
          <label class="field">
            <span>Konto aktuell (h)</span>
            <input type="text" inputmode="decimal" id="glideAccount" placeholder="0.51 oder 0,51" />
          </label>

          <label class="field">
            <span>Zieltyp</span>
            <select id="goalType">
              <option value="delta">Heute Δ (h)</option>
              <option value="account">Konto am Ende (h)</option>
            </select>
            <small class="small">Δ = Arbeit − Soll (Pause zählt nicht in Δ).</small>
          </label>

          <label class="field">
            <span>Zielwert</span>
            <input type="text" inputmode="decimal" id="goalValue" placeholder="z.B. 1.0 oder -0.5" />
          </label>

          <div class="field">
            <span>&nbsp;</span>
            <button class="btn btn--primary" id="btnCalcGoal">Go-Time</button>
            <small class="mono" id="goalResult">—</small>
          </div>
        </div>
      </section>

      <details class="card">
        <summary class="card__title">Erweitert</summary>

        <div class="splitline"></div>

        <div class="card__subtitle">Nachtragen (wenn Start vergessen)</div>
        <div class="grid grid--3">
          <label class="field">
            <span>Ich arbeite seit</span>
            <input type="time" id="workBackdateSince" step="60" />
          </label>
          <label class="field">
            <span>Oder: schon gearbeitet (Min)</span>
            <input type="number" min="0" step="1" id="workBackdateMinutes" placeholder="z.B. 30" />
          </label>
          <div class="field">
            <span>&nbsp;</span>
            <div class="row wrap">
              <button class="btn btn--primary" id="btnApplyBackdate">Übernehmen</button>
              <button class="btn btn--ghost" id="btnApplyBackdateStart">… & Start</button>
            </div>
            <small class="mono" id="backdateResult">—</small>
          </div>
        </div>

        <div class="splitline"></div>

        <div class="card__subtitle">Mobi-Rechner (Eintragzeit / tatsächliche Stoppzeit)</div>
        <div class="grid grid--4">
          <label class="field">
            <span>Eintrag-Uhrzeit</span>
            <input type="time" id="entryTime" step="60" />
            <small class="small">Wenn leer: nimmt „jetzt“.</small>
          </label>

          <label class="field">
            <span>Tatsächlich aufgehört um</span>
            <input type="time" id="actualStopTime" step="60" />
            <small class="small">Wenn leer: nimmt Eintragzeit.</small>
          </label>

          <label class="field">
            <span>Pause-Minuten</span>
            <input type="number" min="0" step="1" id="pauseMinutes" placeholder="z.B. 30" />
          </label>

          <div class="field">
            <span>&nbsp;</span>
            <button class="btn btn--primary" id="btnCalcEntryMinusPause">Ausrechnen</button>
            <small class="mono" id="entryMinusPauseResult">—</small>
          </div>
        </div>

        <div class="splitline"></div>

        <div class="card__subtitle">Wie spät war es vor … Minuten (optional Basiszeit)</div>
        <div class="grid grid--4">
          <label class="field">
            <span>Basis-Uhrzeit</span>
            <input type="time" id="baseTime" step="60" />
            <small class="small">Wenn leer: nimmt „jetzt“.</small>
          </label>

          <label class="field">
            <span>Minuten zurück</span>
            <input type="number" min="0" step="1" id="minutesAgo" placeholder="z.B. 45" />
          </label>

          <div class="field">
            <span>&nbsp;</span>
            <button class="btn btn--ghost" id="btnCalcAgo">Berechnen</button>
            <small class="mono" id="agoResult">—</small>
          </div>

          <div class="field"></div>
        </div>
      </details>
    </section>

    <!-- MOBI TAB -->
    <section id="viewMobi" style="display:none">
      <section class="card">
        <div class="card__title">Mobi</div>
        <div class="hint">Für 1–2 Taps: Start / Pause / Stop. (Start=jetzt ist optional.)</div>

        <div class="mobiActions">
          <button class="btn btn--good btn--xl" id="mobiWorkStart">Start</button>
          <button class="btn btn--warn btn--xl" id="mobiPause">Pause</button>
          <button class="btn btn--danger btn--xl" id="mobiStop">Stop</button>
        </div>

        <div class="row wrap" style="margin-top:12px">
          <button class="btn btn--primary btn--shine" id="mobiStartNow">Start=jetzt & starten</button>
          <button class="btn btn--primary" id="mobiFinish">Arbeitsende</button>
          <span class="mono" id="mobiFinishResult">—</span>
        </div>
      </section>
    </section>

    <footer class="footer">
      <button class="btn btn--ghost" id="btnResetAll">Alles zurücksetzen</button>
      <div class="footer__note">PWA/Offline · Speichert automatisch (localStorage)</div>
    </footer>
  </main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const pad2 = (n) => String(n).padStart(2,"0");
  const KEY = "zeit_pwa_v1";

  function formatHMS(sec){
    sec = Math.max(0, Math.floor(sec));
    const h = Math.floor(sec/3600);
    const m = Math.floor((sec%3600)/60);
    const s = sec%60;
    return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
  }
  function formatHM(d){ return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`; }

  function parseHHMM(str){
    if(!str || !/^\d{2}:\d{2}$/.test(str)) return null;
    const [h,m] = str.split(":").map(Number);
    return h*3600 + m*60;
  }
  function todayAt(sec){
    const d = new Date();
    d.setHours(0,0,0,0);
    return new Date(d.getTime() + sec*1000);
  }
  function parseDecHours(str){
    if(!str) return 0;
    const v = Number(String(str).trim().replace(",", "."));
    return Number.isFinite(v) ? v : 0;
  }

  // PWA install prompt
  let deferredPrompt = null;
  window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredPrompt = e;
    $("btnInstall").style.display = "inline-flex";
  });
  $("btnInstall").addEventListener("click", async () => {
    if(!deferredPrompt) return;
    deferredPrompt.prompt();
    try { await deferredPrompt.userChoice; } catch {}
    deferredPrompt = null;
    $("btnInstall").style.display = "none";
  });

  // Service Worker
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js").catch(()=>{});
  }

  // State
  const defaultTimer = () => ({ status:"stopped", acc:0, lastStart:null });

  const state = {
    theme: "medium",
    tab: "normal",

    dayStart: "",
    targetWork: "07:00",
    requiredBreak: "00:45",

    noGlide: false,
    glideAccount: "",

    autoResume: true,
    notifyOnBreak: false,

    work: defaultTimer(),
    brk: defaultTimer(),
    off: defaultTimer(),

    breakAutoTimeoutId: null
  };

  function save(){ localStorage.setItem(KEY, JSON.stringify(state)); }
  function load(){
    const raw = localStorage.getItem(KEY);
    if(!raw) return;
    try{
      const obj = JSON.parse(raw);
      Object.assign(state, obj);
      state.work = obj.work || defaultTimer();
      state.brk  = obj.brk  || defaultTimer();
      state.off  = obj.off  || defaultTimer();
    }catch{}
  }

  // Timers
  function isRunning(t){ return t.status==="running" && typeof t.lastStart==="number"; }
  function startTimer(t){
    if(isRunning(t)) return;
    t.status="running"; t.lastStart=Date.now();
  }
  function pauseTimer(t){
    if(isRunning(t)) t.acc += (Date.now()-t.lastStart)/1000;
    t.status="paused"; t.lastStart=null;
  }
  function stopTimer(t){
    if(isRunning(t)) t.acc += (Date.now()-t.lastStart)/1000;
    t.status="stopped"; t.lastStart=null;
  }
  function resetTimer(t){
    t.status="stopped"; t.acc=0; t.lastStart=null;
  }
  function seconds(t){
    let s=t.acc;
    if(isRunning(t)) s += (Date.now()-t.lastStart)/1000;
    return s;
  }

  // Off runs when starttime reached and neither work nor break running
  function shouldOffRun(){
    const ds = parseHHMM(state.dayStart);
    if(ds===null) return false;
    if(Date.now() < todayAt(ds).getTime()) return false;
    return !isRunning(state.work) && !isRunning(state.brk);
  }
  function syncOff(){
    const want = shouldOffRun();
    if(want && !isRunning(state.off)) startTimer(state.off);
    if(!want && isRunning(state.off)) pauseTimer(state.off);
  }

  // Planned end = start + target + max(requiredBreak, breakTaken) + offTaken
  function plannedEndForDelta(deltaHours){
    const ds = parseHHMM(state.dayStart);
    const tw = parseHHMM(state.targetWork);
    const rb = parseHHMM(state.requiredBreak);
    if(ds===null || tw===null || rb===null) return null;

    const brTaken = seconds(state.brk);
    const offTaken = seconds(state.off);
    const brCounted = Math.max(rb, brTaken);

    const endMs = todayAt(ds).getTime() + (tw + deltaHours*3600 + brCounted + offTaken)*1000;
    return new Date(endMs);
  }

  function plannedEnd(){
    return plannedEndForDelta(0);
  }

  function remainingWorkSec(){
    const tw = parseHHMM(state.targetWork);
    if(tw===null) return null;
    return Math.max(0, tw - seconds(state.work));
  }

  // Notifications (local)
  function canNotify(){ return "Notification" in window; }
  async function requestNotify(){
    if(!canNotify()) return false;
    if(Notification.permission === "granted") return true;
    const p = await Notification.requestPermission();
    return p === "granted";
  }
  function notify(title, body){
    if(!canNotify()) return;
    if(Notification.permission !== "granted") return;
    try { new Notification(title, { body }); } catch {}
  }

  // Auto-resume when break reaches requiredBreak
  function clearBreakAutoTimer(){
    if(state.breakAutoTimeoutId){
      clearTimeout(state.breakAutoTimeoutId);
      state.breakAutoTimeoutId = null;
    }
  }
  function scheduleBreakAuto(){
    clearBreakAutoTimer();
    if(!state.autoResume) return;
    if(!isRunning(state.brk)) return;

    const rb = parseHHMM(state.requiredBreak);
    if(rb===null) return;

    const already = seconds(state.brk);
    const leftMs = Math.max(0, (rb - already) * 1000);

    state.breakAutoTimeoutId = setTimeout(() => {
      if(isRunning(state.brk)){
        stopTimer(state.brk);
        startTimer(state.work);

        if(state.notifyOnBreak){
          notify("Pflichtpause erfüllt", "Zurück zu Arbeit gestartet.");
        }
        if(navigator.vibrate) navigator.vibrate([80,50,80]);
        save();
      }
    }, leftMs);
  }

  // UI apply/read
  function updateTheme(){
    document.body.dataset.theme = state.theme;
    $("themeSel").value = state.theme;
  }
  function switchTab(tab){
    state.tab = tab;
    $("viewNormal").style.display = tab==="normal" ? "" : "none";
    $("viewMobi").style.display = tab==="mobi" ? "" : "none";
    $("tabNormal").classList.toggle("is-active", tab==="normal");
    $("tabMobi").classList.toggle("is-active", tab==="mobi");
    save();
  }
  function applyUI(){
    $("themeSel").value = state.theme;
    updateTheme();
    switchTab(state.tab);

    $("dayStart").value = state.dayStart || "";
    $("targetWork").value = state.targetWork || "07:00";
    $("requiredBreak").value = state.requiredBreak || "00:45";

    $("noGlide").checked = !!state.noGlide;
    $("glideAccount").value = state.glideAccount || "";
    $("glideCard").style.display = state.noGlide ? "none" : "";

    $("autoResume").checked = !!state.autoResume;
    $("notifyOnBreak").checked = !!state.notifyOnBreak;
  }
  function readUI(){
    state.theme = $("themeSel").value;
    state.dayStart = $("dayStart").value;
    state.targetWork = $("targetWork").value || "07:00";
    state.requiredBreak = $("requiredBreak").value || "00:45";
    state.noGlide = $("noGlide").checked;
    state.glideAccount = $("glideAccount").value || "";
    state.autoResume = $("autoResume").checked;
    state.notifyOnBreak = $("notifyOnBreak").checked;
    save();
    applyUI();
  }

  // Start now & start work
  function startNowAndWork(){
    const n = new Date();
    const v = `${pad2(n.getHours())}:${pad2(n.getMinutes())}`;
    $("dayStart").value = v;
    readUI();

    stopTimer(state.brk);
    stopTimer(state.off);
    startTimer(state.work);
    save();
  }

  // Finish day: stop all and update glide account
  function finishDay(){
    stopTimer(state.work);
    stopTimer(state.brk);
    stopTimer(state.off);
    clearBreakAutoTimer();

    const tw = parseHHMM(state.targetWork);
    const worked = seconds(state.work);

    let msg = `Arbeit: ${formatHMS(worked)} · Soll: ${tw ? formatHMS(tw) : "—"}`;

    if(!state.noGlide && tw !== null){
      const deltaH = (worked - tw)/3600;
      const newAcc = parseDecHours(state.glideAccount) + deltaH;
      state.glideAccount = (Math.round(newAcc*100)/100).toFixed(2);
      msg = `Δ heute: ${(deltaH>=0?"+":"")}${deltaH.toFixed(2)} h · Konto: ${state.glideAccount} h`;
      $("glideAccount").value = state.glideAccount;
    }
    save();
    return msg;
  }

  // Render
  function render(){
    const now = new Date();
    $("bigClock").textContent = `${pad2(now.getHours())}:${pad2(now.getMinutes())}:${pad2(now.getSeconds())}`;
    $("todayLine").textContent = now.toLocaleDateString("de-DE", { weekday:"long", year:"numeric", month:"2-digit", day:"2-digit" });

    syncOff();

    const w = seconds(state.work);
    const b = seconds(state.brk);
    const o = seconds(state.off);

    $("heroWork").textContent = formatHMS(w);
    $("heroSub").textContent = `Pause ${formatHMS(b)} · Unterbr. ${formatHMS(o)}`;

    $("workStatus").textContent = state.work.status;
    $("breakStatus").textContent = state.brk.status;

    const end = plannedEnd();
    if(end){
      $("endTime").textContent = formatHM(end);
      const tw = parseHHMM(state.targetWork) ?? 0;
      const rb = parseHHMM(state.requiredBreak) ?? 0;
      const brCounted = Math.max(rb, b);
      $("endSub").textContent = `Start ${state.dayStart || "—"} · Pause zählt ${formatHMS(brCounted)}`;
    }else{
      $("endTime").textContent = "—";
      $("endSub").textContent = "Startzeit setzen";
    }

    scheduleBreakAuto();
    save();
  }

  // Events
  function hook(){
    $("tabNormal").addEventListener("click", ()=>switchTab("normal"));
    $("tabMobi").addEventListener("click", ()=>switchTab("mobi"));

    $("themeSel").addEventListener("change", readUI);

    ["dayStart","targetWork","requiredBreak","noGlide","glideAccount","autoResume","notifyOnBreak"].forEach(id=>{
      $(id).addEventListener("input", readUI);
      $(id).addEventListener("change", readUI);
    });

    $("btnStartNow").addEventListener("click", startNowAndWork);
    $("mobiStartNow").addEventListener("click", startNowAndWork);

    // Main work controls
    $("workStart").addEventListener("click", ()=>{ stopTimer(state.brk); stopTimer(state.off); startTimer(state.work); save(); });
    $("workPause").addEventListener("click", ()=>{ pauseTimer(state.work); save(); });
    $("workStop").addEventListener("click", ()=>{ stopTimer(state.work); save(); });

    // Mobi controls
    $("mobiWorkStart").addEventListener("click", ()=>{ stopTimer(state.brk); stopTimer(state.off); startTimer(state.work); save(); });
    $("mobiPause").addEventListener("click", ()=>{
      // Pause = Arbeit pausieren + Pause starten
      pauseTimer(state.work);
      startTimer(state.brk);
      save();
      scheduleBreakAuto();
    });
    $("mobiStop").addEventListener("click", ()=>{
      stopTimer(state.work);
      stopTimer(state.brk);
      stopTimer(state.off);
      clearBreakAutoTimer();
      save();
    });

    // On normal: pause behavior (same as mobi pause)
    // NOTE: To keep UI simple, we use the same main Pause button to start break (not just pause work).
    // If you want "Pause" to only pause work, tell me; I can split it.
    $("workPause").addEventListener("dblclick", ()=>{
      // double-click: start actual break
      pauseTimer(state.work);
      startTimer(state.brk);
      save();
      scheduleBreakAuto();
    });

    $("btnEnableNotify").addEventListener("click", async ()=>{
      const ok = await requestNotify();
      if(ok){
        state.notifyOnBreak = true;
        $("notifyOnBreak").checked = true;
        save();
        notify("Notifications aktiv", "Pflichtpause-Hinweis funktioniert, solange die App läuft.");
      }
    });

    $("btnFinishDay").addEventListener("click", ()=>{
      $("finishResult").textContent = finishDay();
    });
    $("mobiFinish").addEventListener("click", ()=>{
      $("mobiFinishResult").textContent = finishDay();
    });

    // Goal calculator (single)
    $("btnCalcGoal").addEventListener("click", ()=>{
      if(state.noGlide){ $("goalResult").textContent = "— Keine Gleitzeit aktiv"; return; }

      const type = $("goalType").value; // delta|account
      const v = parseDecHours($("goalValue").value);

      if(!Number.isFinite(v)){ $("goalResult").textContent = "— Ungültiger Wert"; return; }

      const nowAcc = parseDecHours(state.glideAccount);
      const needDelta = (type === "delta") ? v : (v - nowAcc);

      const end = plannedEndForDelta(needDelta);
      $("goalResult").textContent = end
        ? `Go-Time: ${formatHM(end)} (${type === "delta" ? "Δ" : "Konto"} → ${v.toFixed(2)} h)`
        : "— Startzeit/Soll setzen";
    });

    // Backdate
    function applyBackdate(alsoStart){
      const since = $("workBackdateSince").value;
      const minsStr = $("workBackdateMinutes").value;
      const now = new Date();

      if(since){
        const sec = parseHHMM(since);
        if(sec===null){ $("backdateResult").textContent="— Ungültige Uhrzeit"; return; }
        const diff = Math.max(0, (now.getTime() - todayAt(sec).getTime())/1000);
        state.work.acc = diff;
        state.work.status = alsoStart ? "running" : "paused";
        state.work.lastStart = alsoStart ? Date.now() : null;
        $("backdateResult").textContent = `OK: Arbeit = ${formatHMS(diff)} (seit ${since})`;
        save();
        return;
      }

      const mins = Number(minsStr);
      if(Number.isFinite(mins) && mins >= 0){
        state.work.acc = mins*60;
        state.work.status = alsoStart ? "running" : "paused";
        state.work.lastStart = alsoStart ? Date.now() : null;
        $("backdateResult").textContent = `OK: Arbeit = ${formatHMS(mins*60)}`;
        save();
        return;
      }

      $("backdateResult").textContent = "— Bitte „seit“ oder Minuten eintragen";
    }
    $("btnApplyBackdate").addEventListener("click", ()=>applyBackdate(false));
    $("btnApplyBackdateStart").addEventListener("click", ()=>applyBackdate(true));

    // Entry minus pause calculator
    $("btnCalcEntryMinusPause").addEventListener("click", ()=>{
      const entry = $("entryTime").value;
      const stop  = $("actualStopTime").value;
      const pauseMin = Number($("pauseMinutes").value || 0);

      const now = new Date();
      const entrySec = entry ? parseHHMM(entry) : (now.getHours()*3600 + now.getMinutes()*60);
      const stopSec  = stop  ? parseHHMM(stop)  : entrySec;

      if(entrySec===null || stopSec===null || !Number.isFinite(pauseMin) || pauseMin < 0){
        $("entryMinusPauseResult").textContent = "— Ungültige Eingabe";
        return;
      }
      const base = todayAt(stopSec);
      const out = new Date(base.getTime() - pauseMin*60*1000);
      $("entryMinusPauseResult").textContent = `${formatHM(base)} − ${pauseMin} min = ${formatHM(out)}`;
    });

    // Minutes ago
    $("btnCalcAgo").addEventListener("click", ()=>{
      const base = $("baseTime").value;
      const mins = Number($("minutesAgo").value);

      if(!Number.isFinite(mins) || mins < 0){ $("agoResult").textContent = "—"; return; }

      let baseDate;
      if(base){
        const sec = parseHHMM(base);
        if(sec===null){ $("agoResult").textContent = "— Ungültige Basiszeit"; return; }
        baseDate = todayAt(sec);
      } else {
        baseDate = new Date();
      }

      const d = new Date(baseDate.getTime() - mins*60*1000);
      $("agoResult").textContent = `Vor ${mins} min: ${formatHM(d)}`;
    });

    $("btnResetAll").addEventListener("click", ()=>{
      if(!confirm("Wirklich alles zurücksetzen?")) return;
      localStorage.removeItem(KEY);
      location.reload();
    });
  }

  load();
  applyUI();
  hook();
  render();
  setInterval(render, 250);
})();
</script>
</body>
</html>